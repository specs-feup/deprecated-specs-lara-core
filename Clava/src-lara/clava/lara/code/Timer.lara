import lara.code.TimerBase;
import lara.code.Logger;
import lara.util.IdGenerator;

/**
 * C++ std::chrono macros
 */
Timer.prototype._cpp_TimeUnit = {
    1: "nanoseconds",
    2: "microseconds",
    3: "milliseconds",
    4: "seconds",
    5: "minutes",
    6: "hours",
    7: undefined,
}

/**
 * Times the code of a given section.
 * 
 * @param $start [Mandatory] Starting point of the time measure
 * @param prefix Message that will appear before the time measure. If undefined, empty string will be used.
 * @param $end Ending point of the time measure. If undefined, measure is done around starting point.
 */
Timer.prototype.time = function($start, prefix, $end) {

	if(!this._timeValidate($start, $end, 'function')) {
		return;
	}

	var $file = $start.ancestor('file');

    if ($file.isCxx) {
		this._time_cpp($start, prefix, $end);
        return;
    } 
	
	PrintOnce.message("Timer.time: not implemented yet for C");
}


Timer.prototype._time_cpp = function($start, prefix, $end) {

	var logger = new Logger(false, this.filename);
	
	// Build prefix
	if(prefix === undefined) {
		prefix = "";
	}

	if($end === undefined) {
		$end = $start;
	}

	$file = $start.ancestor("file");
		
		
	// Add include
	$file.addInclude("chrono", true);
	

	var startVar = IdGenerator.next("clava_timing_start_");
	var endVar = IdGenerator.next("clava_timing_end_");
	
	var codeTic = _timer_cpp_now(startVar);
	var codeToc = _timer_cpp_now(endVar);

	var cppUnit = this._cpp_TimeUnit[this.unit];
	
	// Create literal node with calculation of time interval
	$timingResult = AstFactory.exprLiteral(_timer_cpp_calc_interval(startVar, endVar, cppUnit));
	
	// Declare variable for time interval, which uses calculation as initialization
	var timeIntervalVar = IdGenerator.next("clava_timing_durantion_");
	$timingResultDecl = AstFactory.varDecl(timeIntervalVar, $timingResult);
	
	// Build message
	logger.append(prefix).appendDouble(timeIntervalVar);
	if(this.printUnit) {
		logger.append(this.getUnitsString());
	}
	logger.ln();
	
	// Insert code
    $start.insertBefore(codeTic);
	
	// 'after' insertions must be done in reverse order		
	$end.insertAfter($timingResultDecl);
	$end.insertAfter(codeToc);

	
	// Log time information
	logger.log($timingResultDecl);		
}

codedef _timer_cpp_now(timeVar) %{
std::chrono::high_resolution_clock::time_point [[timeVar]] = std::chrono::high_resolution_clock::now();
}% end

codedef _timer_cpp_calc_interval(startVar, endVar, unit) %{
std::chrono::duration_cast<std::chrono::[[unit]]>( [[endVar]] - [[startVar]] ).count()
}% end
