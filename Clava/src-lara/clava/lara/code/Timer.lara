import lara.code.TimerBase;
import lara.code.Logger;
import lara.util.IdGenerator;
import lara.util.Platforms;

/**
 * C++ std::chrono macros
 */
Timer.prototype._cpp_TimeUnit = {
    1: "nanoseconds",
    2: "microseconds",
    3: "milliseconds",
    4: "seconds",
    5: "minutes",
    6: "hours",
    7: undefined,
}

/**
 * Times the code of a given section.
 * 
 * @param $start [Mandatory] Starting point of the time measure
 * @param prefix Message that will appear before the time measure. If undefined, empty string will be used.
 * @param $end Ending point of the time measure. If undefined, measure is done around starting point.
 */
Timer.prototype.time = function($start, prefix, $end) {

    if (!this._timeValidate($start, $end, 'function')) {
        return;
    }

    var $file = $start.ancestor('file');

    if ($file.isCxx) {
        this._time_cpp($start, prefix, $end);
    } else {
        this._time_c($start, prefix, $end);
    }

    return this;
    //PrintOnce.message("Timer.time: not implemented yet for C");
}


Timer.prototype._time_cpp = function($start, prefix, $end) {

    var logger = new Logger(false, this.filename);

    // Build prefix
    if (prefix === undefined) {
        prefix = "";
    }

    if ($end === undefined) {
        $end = $start;
    }

    $file = $start.ancestor("file");


    // Add include
    $file.addInclude("chrono", true);


    var startVar = IdGenerator.next("clava_timing_start_");
    var endVar = IdGenerator.next("clava_timing_end_");

    var codeTic = _timer_cpp_now(startVar);
    var codeToc = _timer_cpp_now(endVar);

    var cppUnit = this._cpp_TimeUnit[this.unit];

    // Create literal node with calculation of time interval
    $timingResult = AstFactory.exprLiteral(_timer_cpp_calc_interval(startVar, endVar, cppUnit));

    // Declare variable for time interval, which uses calculation as initialization
    var timeIntervalVar = IdGenerator.next("clava_timing_durantion_");
    $timingResultDecl = AstFactory.varDecl(timeIntervalVar, $timingResult);

    // Build message
    logger.append(prefix).appendDouble(timeIntervalVar);
    if (this.printUnit) {
        logger.append(this.getUnitsString());
    }
    logger.ln();

    // Insert code
    $start.insertBefore(codeTic);

    // 'after' insertions must be done in reverse order		
    $end.insertAfter($timingResultDecl);
    $end.insertAfter(codeToc);


    // Log time information
    logger.log($timingResultDecl);
}

Timer.prototype._time_c = function($start, prefix, $end) {

    var logger = new Logger(false, this.filename);

    // Build prefix
    if (prefix === undefined) {
        prefix = "";
    }

    if ($end === undefined) {
        $end = $start;
    }

    $file = $start.ancestor("file");

    return;
    
    var codeBefore, codeAfter, timeIntervalVar;

    // Declare variable for time interval, which uses calculation as initialization
    var timeIntervalVar = IdGenerator.next("clava_timing_durantion_");
    var $timingResultDecl;
    if (Platforms.isWindows()) { //use QueryPerformanceCounter
        // Add includes
        $file.addInclude("time.h", true);
        $file.addInclude("windows.h", true);

        // get variable names
        var startVar = IdGenerator.next("clava_timing_start_");
        var endVar = IdGenerator.next("clava_timing_end_");
        var frequencyVar = IdGenerator.next("clava_timing_frequency_");

        codeBefore = _timer_c_windows_declare_vars(startVar, endVar, frequencyVar);
        codeAfter = _timer_c_windows_get_final_time(endVar);

        // Create literal node with calculation of time interval
        $timingResult = AstFactory.exprLiteral(_timer_c_windows_calc_interval(startVar, endVar, frequencyVar));
        $timingResultDecl = AstFactory.varDecl(timeIntervalVar, $timingResult);
    } else if (Platforms.isLinux() || Platforms.isUnix()) {

    }





    // Build message
    logger.append(prefix).appendDouble(timeIntervalVar);
    if (this.printUnit) {
        logger.append(this.getUnitsString());
    }
    logger.ln();

    // Insert code
    $start.insertBefore(codeTic);

    // 'after' insertions must be done in reverse order		
    $end.insertAfter($timingResultDecl);
    $end.insertAfter(codeToc);


    // Log time information
    logger.log($timingResultDecl);
}

//C codedefs 
// Windows
codedef _timer_c_windows_declare_vars_now(timeStartVar, timeEndVar, timeFrequencyVar)%{
	LARGE_INTEGER [[timeStartVar]], [[timeEndVar]], [[timeFrequencyVar]];
	double tempDeltaTime; 
    QueryPerformanceFrequency(&[[timeFrequencyVar]]);
    QueryPerformanceCounter(&[[timeStartVar]]);
}%end
codedef _timer_c_windows_get_final_time(timeEndVar)%{
    QueryPerformanceCounter(&[[timeEndVar]]);
}%end
codedef _timer_c_windows_calc_interval(timeStartVar, timeEndVar, timeFrequencyVar)%{
    ([[timeEndVar]].QuadPart-[[timeStartVar]].QuadPart) / (double)[[timeFrequencyVar]].QuadPart;
}%end


//Cpp codedefs
codedef _timer_cpp_now(timeVar)%{
    std::chrono::high_resolution_clock::time_point[[timeVar]] = std::chrono::high_resolution_clock::now();
}%end

codedef _timer_cpp_calc_interval(startVar, endVar, unit)%{
    std::chrono::duration_cast < std::chrono::[[unit]] > ([[endVar]] - [[startVar]]).count()
}%end