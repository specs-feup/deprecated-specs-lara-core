/**
 * Logger object, for printing/saving information.
 */
var Logger = function(isGlobal, filename) {
  
  //(new lara$profiling$Energy$EnergyTest()).call();
  if(isGlobal) {
	println("[Logger-warning] global Logger is not implemented yet, reverting to local Logger");
	isGlobal = false;
  }
  
  this.currentElements = [];
  
  //this.functionsSetup = new Set();
  this.functionMap = {}; 
  
  this.isGlobal = isGlobal === undefined ? false : isGlobal;
  this.filename = filename;

};

// Using enum pattern described here: https://stijndewitt.com/2014/01/26/enums-in-javascript/
Logger.prototype.Type = {
	NORMAL: 1,
	INT: 	2,
	DOUBLE: 3,
	STRING: 4,
	CHAR: 	5,
	HEX:	6,
	OCTAL:	7,
	// C printf format
	CFormat: {
		1: "%s",
		2: "%d",
		3: "%f",
		4: "%s",
		5: "%c",
		6: "%x",
		7: "%o"
	}
}


Logger.prototype.isGlobalFn = function() {  
    println("Is Global Fn:" + this.isGlobal);
}

// Private append function
Logger.prototype._append_private = function(message, type) {
	// Do not push message if empty
	if(message === "") {
		return this;
	}
	
	// Force type to be defined
	if(type === undefined) {
		throw "Logger: type must be defined";
	}
	//type = type === undefined
	/*
	// Check type, if undefined use default (%s)
	type = type === undefined ? "%s" : type;
	
	// Add quotes for string output
	if(type == "%s"){
		message = "\"" + message + "\"";
	} else if( type == "%c"){
		//Add ' instead of " for char, even in C++
		message = '\'' + message + '\'';
	} 
	*/
	
	this.currentElements.push({content: message, type:type});
	return this;
}

Logger.prototype.append = function(expr) {
	return this._append_private(expr, this.Type.NORMAL);
}

Logger.prototype.appendDouble = function(expr) {
	return this._append_private(expr, this.Type.DOUBLE);
}

Logger.prototype.appendInt = function(expr) {
	return this._append_private(expr, this.Type.INT);
}

Logger.prototype.appendString = function(expr) {
	return this._append_private(expr, this.Type.STRING);
}

Logger.prototype.appendChar = function(expr) {
	return this._append_private(expr, this.Type.CHAR);
}

Logger.prototype.appendHex = function(expr) {
	return this._append_private(expr, this.Type.HEX);
}

Logger.prototype.appendOctal = function(expr) {
	return this._append_private(expr, this.Type.OCTAL);
}

Logger.prototype.log = function($jp, insertBefore) {
	
	// Verify that $jp is inside a function
	$function = $jp.ancestor("function");
	if($function === undefined) {
		_warn("Given joinpoint ("+$jp+") is not inside a function, returning");
		return;
	}
	
	
	if(this.currentElements.length === 0) {
		_info("Nothing to log, call append() first");
		return;
	}

	
	var $file = $function.ancestor('file');
	
	var code = undefined;
	if($file.isCxx) {
		code = this._log_cxx($file, $function);
	} else {
		code = this._log_c($file, $function);
	}
	
	if(code === undefined) {
		return;
	}
		
	if(insertBefore === undefined) {
		insertBefore = false;
	}
	
	//call LoggerInsert($jp, code, insertBefore);
	if(insertBefore) {
		$jp.insertBefore(code);
	}else {
		$jp.insertAfter(code);
	}
	
	// Clear internal state
	this.currentElements = [];
}


/**** PRIVATE METHODS ****/

Logger.prototype._warn = function(message) {
		println("[Logger Warning] " + message);
}

Logger.prototype._info = function(message) {
		println("[Logger] " + message);
}

// Receives an element{content, type} and return the content with or without quotation marks, accordingly
Logger.prototype._getPrintableContentC_Cxx = function(element) {
	var enumType = this.Type;
	var content = element.content;
	if(element.type === enumType.NORMAL || element.type === enumType.STRING ) {
		content = "\"" + content + "\"";
	}else if(element.type === enumType.CHAR){
		content = "\'" + content + "\'";
	}
	return content;
}

Logger.prototype._log_cxx = function($file, $function) {
	
	var loggerName = this._setup_cxx($file, $function);
    
	if(loggerName === undefined) {
		return;
	}
	
	// Create code from elements
	var code = loggerName + ".msg(" + this.currentElements.map(function(element){
		return this._getPrintableContentC_Cxx(element);
	}, this).join(", ") + ");";
	
	return code;
}

/**
 * Sets up the code for the Logger in the file and function that is called
 */
Logger.prototype._setup_cxx = function($file, $function) {

	// Check if setup was already called for this function
	var declaration = $function.declaration(true);
	var loggerName = this.functionMap[declaration];
    
	if(loggerName !== undefined) {
		return loggerName;
	} else {
		loggerName = IdGenerator.next("clava_logger_");
		this.functionMap[declaration] = loggerName;
	}

	// Add include to Logger for Cpp only
	$file.addInclude("SpecsLogger.h", false);
	
	// Get correct logger
	var loggerDecl = undefined;
	
	// If filename use FileLogger 
	if(this.filename !== undefined) {
		loggerDecl = "FileLogger " + loggerName + "(\"" + this.filename + "\");";
	}
	// Otherwise, use ConsoleLogger
	else {
		loggerDecl = "ConsoleLogger " + loggerName + ";";
	}
	
	// Add declaration of correct logger
	$function.body.insertBegin(loggerDecl);	
	
	return loggerName;
}

Logger.prototype._log_c = function($file, $function) {

		if(!this._setup_c($file, $function)) {
			return;
		}

		var code = "printf(\"" +
		this.currentElements.map(function(element){
			var enumType = this.Type;
			if(element.type === enumType.NORMAL){
				return element.content;
			}
			return enumType.CFormat[element.type];
		}, this).join("") + "\"," +
		this.currentElements
		// Filter only non-NORMAL types
		.filter(function(element) {
			var enumType = this.Type;
			return (element.type !== enumType.NORMAL);
		}, this)
		.map(function(element){
			// Even though _getPrintableContentC_Cxx tests an always unmet condition (type === NORMAL) it represents a reusable piece of code for both C and C++
			return this._getPrintableContentC_Cxx(element);
		}, this).join(",") + ");";
		
		return code;
}

/**
 * Sets up the code for the Logger in the file that is called
 */
Logger.prototype._setup_c = function($file, $function) {

	// Add stdio.h if console, not implemented yet for file
	println("Filename:" + this.filename);
	if(this.filename !== undefined) {
		this._warn('Not implemented for C files when a "filename" is defined');
		return false;
	}
	
	$file.addInclude("stdio.h", true);

	return true;
}


