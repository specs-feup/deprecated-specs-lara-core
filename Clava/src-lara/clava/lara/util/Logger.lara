/**
 * Logger object, for printing/saving information.
 */
var Logger = function(isGlobal, filename) {
  
  //(new lara$profiling$Energy$EnergyTest()).call();
  if(isGlobal) {
	println("[Logger-warning] global Logger is not implemented yet, reverting to local Logger");
	isGlobal = false;
  }
  
  this.currentElements = [];
  //this.functionsSetup = new Set();
  this.functionMap = {}; 
  
  this.isGlobal = isGlobal === undefined ? false : isGlobal;
  this.filename = filename;

};


Logger.prototype.isGlobalFn = function() {  
    println("Is Global Fn:" + this.isGlobal);
}

//Accepts a c printf format type (e.g. %d, %s, %c, ...) default is %s
Logger.prototype.append = function(message, type) {
	// Do not push message if empty
	if(message === "") {
		return this;
	}
	
	// Check type, if undefined use default (%s)
	type = type === undefined ? "%s" : type;
	
	// Add quotes for string output
	if(type == "%s"){
		message = "\"" + message + "\"";
	} else if( type == "%c"){
		//Add ' instead of " for char, even in C++
		message = '\'' + message + '\'';
	} 
	
	this.currentElements.push({content: message, type:type});
	return this;
}


Logger.prototype.appendDouble = function(expr) {
	return this.append(expr, "%f");
}

Logger.prototype.appendInt = function(expr) {
	return this.append(expr, "%d");
}

Logger.prototype.log = function($jp, insertBefore) {
	
	// Verify that $jp is inside a function
	$function = $jp.ancestor("function");
	if($function === undefined) {
		_warn("Given joinpoint ("+$jp+") is not inside a function, returning");
		return;
	}
	
	
	var loggerName = this._setup($function);
    if(loggerName === undefined) {
		return;
	}

	if(insertBefore === undefined) {
		insertBefore = false;
	}
	
	if(this.currentElements.length === 0) {
		_info("Nothing to log, call add() first");
		return;
	}
	
	var $file = $function.ancestor('file');
	
	var code;
	
	//C and C++ support for file log implementation
	if($file.isCxx){//C++
		// Create code from elements
		code = loggerName + ".msg(" + this.currentElements.map(function(element){
			return element.content;
		}).join(",") + ");";
	} else {//C
		code = "printf(\"" +
		this.currentElements.map(function(element){
			return element.type;
		}).join("") + "\"," +
		this.currentElements.map(function(element){
			return element.content;
		}).join(",") + ");";
	}
	
	
	//call LoggerInsert($jp, code, insertBefore);
	if(insertBefore) {
		$jp.insertBefore(code);
	}else {
		$jp.insertAfter(code);
	}
	
	// Clear internal state
	this.currentElements = [];
}


/**** PRIVATE METHODS ****/

Logger.prototype._warn = function(message) {
		println("[Logger Warning] " + message);
}

Logger.prototype._info = function(message) {
		println("[Logger] " + message);
}

/**
 Sets up the code for the Logger in the function that is called
 */
Logger.prototype._setup = function($function) {

	// Check if setup was already called for this function
	var declaration = $function.declaration(true);
	var loggerName = this.functionMap[declaration];

	if(loggerName !== undefined) {
		return loggerName;
	} else {
		loggerName = IdGenerator.next("clava_logger_");
		this.functionMap[declaration] = loggerName;
	}

	
	var $file = $function.ancestor('file');
	
	if($file.isCxx) {
		// Add include to Logger for Cpp only
		$file.addInclude("SpecsLogger.h", false);
	}
	
	// Get correct logger
	var loggerDecl = undefined;
	
	// If filename use FileLogger 
	if(this.filename !== undefined) {
		loggerDecl = "FileLogger " + loggerName + "(\"" + this.filename + "\");";
	}
	// Otherwise, use ConsoleLogger
	else {
		loggerDecl = "ConsoleLogger " + loggerName + ";";
	}
	
	// Add declaration of correct logger
	$function.body.insertBegin(loggerDecl);

	return loggerName;
}


